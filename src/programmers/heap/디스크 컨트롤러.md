# 디스크 컨트롤러

- - - -
## 문제 조건
### 목적
~**평균 작업시간**의 최소화~
* 먼저 끝낼 수 있는 일은 먼저 끝내야 평균 작업시간이 최소화 된다.
* **Shortest Job First**


### 제한조건
* 하드디스크가 idle 상태이면 FIFO로 작업 처리
- - - -
## 풀이과정
### 클래스 구성
1. HardDiskSystem
	* 요청될 작업과 요청된 작업을 저장할 2개의 Queue
	* 현재 시간 
		* 요청될 작업과 요청된 작업을 구분하기 위해 사용
	* 총 소요시간
		* 소요시간 = 각 작업이 요청된 시점에서 처리가 완료된 시점까지 걸린 시간
		* 총 소요시간 = 모든 작업들의 소요시간의 합
	* 전체 작업의 수 & 현재까지 완료한 작업의 수 
		* 종료조건으로 활용
2. Job
	* 요청 시간
	* 작업 시간

### 요청된 작업과 요청될 작업의 구분
* 2개의 PriorityQueue를 이용
	1. waitQueue : 요청될 작업
		* 앞으로 들어올 요청들을 저장한다.
		* 빠른 요청 순으로 뽑기 위해 요청 시간을 기준으로 오름차순 정렬한다.
	2. jobQueue : 요청된 작업
		* 현재 시간을 기준으로 요청된 작업들을 저장한다.
		* 빨리 끝낼 수 있는 작업 순으로 뽑기 위해 작업 시간을 기준으로 오름차순 정렬한다.

### 테스트
* 예시 시나리오 
```java
int[][] jobs = {
	{0, 5},
	{6, 1},
	{2, 4},
	{1, 5}
}
```

1. 시작 직전에 준비된 상태
```java
// 현재시간 = 0
waitQueue = [{0, 5}, {1, 5}, {2, 4}, {6, 1}];
jobQueue = [];
```
2. 시작 직후 현재시간은 0이다. 이 때 요청될 작업과 요청된 작업을 구분하면 아래와 같다.
현재 시간을 기준으로 현재시간보다 이른 시점에 요청된 작업들을 모두 waitQueue에서 꺼내 jobQueue로 옮긴다.
```java
// 현재시간 = 0
waitQueue = [{1, 5}, {2, 4}, {6, 1}];
jobQueue = [{0, 5}];
```
3. jobQueue에 작업이 있다면 하나를 수행한다. 작업 완료 이후 모습은 아래와 같다. 작업을 하나만 수행하고 다음 과정으로 넘어가야 경과한 시간에 따른 새로운 요청을 반영할 수 있다.
```java
// 현재시간 = 5
// 총 소요시간 = 5
waitQueue = [{1, 5}, {2, 4}, {6, 1}];
jobQueue = [];
```
4. 완료한 작업의 수가 전체 작업의 수와 같아질 때 까지 2와 3을 반복한다. 전체 진행과정은 아래와 같다.
```java
// 스케줄링
// 현재시간 = 5
// 총 소요시간 = 5
waitQueue = [{6, 1}];
jobQueue = [{2, 4}, {1, 5}];
```

```java
// 작업 수행
// 현재시간 = 9
// 총 소요시간 = 12
waitQueue = [{6, 1}];
jobQueue = [{1, 5}];
```

```java
// 스케줄링
// 현재시간 = 9
// 총 소요시간 = 12
waitQueue = [];
jobQueue = [{6, 1}, {1, 5}];
```

```java
// 작업 수행
// 현재시간 = 10
// 총 소요시간 = 16
waitQueue = [];
jobQueue = [{1, 5}];
```

```java
// 스케줄링(wait Queue is empty) & 작업 수행
// 현재시간 = 15
// 총 소요시간 = 30
waitQueue = [];
jobQueue = [];
```
5. 총 소요시간은 30ms이고 작업의 수는 4 이므로 30 / 4 = 7.5 -> 7
따라서 모든 작업을 처리하는데 걸리는 최소 평균 작업 시간은 7ms이다.